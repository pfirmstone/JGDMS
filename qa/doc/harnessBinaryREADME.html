<!--
 ! Licensed to the Apache Software Foundation (ASF) under one
 ! or more contributor license agreements.  See the NOTICE file
 ! distributed with this work for additional information
 ! regarding copyright ownership. The ASF licenses this file
 ! to you under the Apache License, Version 2.0 (the
 ! "License"); you may not use this file except in compliance
 ! with the License. You may obtain a copy of the License at
 ! 
 !      http://www.apache.org/licenses/LICENSE-2.0
 ! 
 ! Unless required by applicable law or agreed to in writing, software
 ! distributed under the License is distributed on an "AS IS" BASIS,
 ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ! See the License for the specific language governing permissions and
 ! limitations under the License.
 !-->
<html>
<body>

The <code>org.apache.river.qa.harness</code> package provides a specialized testing
infrastructure designed to support testing of Jini(TM) technology-enabled
components and services. This overview provides information of general interest
both to test developers and to deployers. A partial list of features provided by
this environment includes:

<ul>
<li>Transparent management of the activation system
<li>Transparent management of class servers
<li>A simple mechanism for starting and stopping Jini services
<li>Support for activatable, persistent, and transient services
<li>Support for running services in a shared virtual machine (VM), or in separate VMs
<li>Support for secure and non-secure configurations
<li>Support for distributing tests over multiple hosts
<li>Automatic generation of httpmd URLs for codebases
<li>Control of classpath, codebase, policy, etc. on a per-test/per-service basis
<li>A hierarchical and flexible configuration database
</ul>

Tests are always run in a separate VM, allowing per-test assignments for
classpath, codebase, etc. Each test has an associated
<code>net.jini.config.Configuration</code> object.  Other parameter sources are
also used by tests, such as property files and command-line arguments.  This
document occasionally uses the generic term "configuration" to refer to the
entire collection of sources available for obtaining test parameters and
<code>Configuration</code> objects. The terms <code>Configuration</code> and
<code>ConfigurationFile</code> (code font) will be used when referring to an
object from the <code>net.jini.config</code> package, and the term
ConfigurationFile (normal font) will be used to refer to a file from which a
<code>ConfigurationFile</code> object may be derived.

<h2>Installation Directories</h2>

The test harness and the Jini Technology Starter Kit (starter kit) 
may be installed in user selected directories. Installation parameters 
and user-supplied properties that control harness execution are
provided in a <code>deployment properties file</code>
 which is named on the command line used to run the
harness. The directory containing the starter kit is identified in this file by
the property <code>jsk.home</code>. The directory containing the
test harness kit is identified in this file by the property
<code>qa.home</code>. In property files, and frequently in this
document, these directories will be referred to symbolically as
<code>${jsk.home}</code> and <code>${qa.home}</code>.
The test suite to be executed by the harness is installed separately and
may require additional properties to define the installation environment
of the test suite.

<p>

<h2>Distributed Execution</h2>

The test harness supports a distributed mode of execution, in which
the test runs on a master host, and services are started on the master
host or on a slave host. The master can support an arbitrary number
of slaves. The test harness must be started on every participant,
and the command line must include a system property that names
the participants. For example, the definition:

<pre>
  -Dorg.apache.river.qa.harness.testhosts=foo,bar
</pre>

would indicate that two hosts, named foo and bar, are participants.  The first
name in the list is interpreted as the master. The harness does not begin
executing tests until all participants have been started.  Any logging output
generated on the slave host will be merged into the logging output generated by
the master.  All harness and test properties are
transmitted from the master to the slave at test execution time.
However, the slave obtains installation properties from its
own deployment properties file.  This allows
participants to be a mix of platforms and to have different installation
characteristics.

<p>

When a test starts a service, the master selects the service host based on the
current host selection policy. The policy to use is defined by the value of the
test property <code>org.apache.river.harness.servicehostpolicy</code>. This property
may have one of the following values:

<dl>
  <dt> <code>random</code>           
      <dd> host is selected at random from all participants

  <dt> <code>remoterandom</code>      
      <dd>host is selected at random from slaves

  <dt> <code>roundrobin</code>       
      <dd>service host is selected in sequence from
	  the ordered list of participants, starting from the
          first slave. The master is the last host chosen.

  <dt> <code>remoteroundrobin</code>  
      <dd>service host is selected in sequence
          from the ordered list of slaves. The master is
	  never selected.
</dl>
This policy may be overridden on a per-service basis; see the
<code>hosts</code> service property for details. The most common use of such an
override is to force a test service to always run on the master, due to
some assumption built into the test service or the test.

<h2>The Kits</h2>
There are two versions of the harness kit. The <code>binary kit</code>
is a packaging that contains the minimum set of files
sufficient to provide full functionality.
The harness provides mechanisms to access resources in
the harness and test suite JAR files.  The packaging of the 
binary distribution takes advantage of this by placing most
resource files supplied in the harness source distribution into the
harness JAR file. This includes policy files, ConfigurationFiles,
and property files. One resource cannot be accessed via
a URL (the JAAS trust store) and is included as file in the kit.
The binary kit is targeted for production testing, and is
the kit used for production testing by the Jini Technology Group.
<p>
There is also a <code>source kit</code> which provides all of the Java
source files and resource files needed to build the harness, as well
as the javadoc for the harness API. The JAR files from the binary kit 
are also included.

<h2>Accessing resources</h2>

Property definitions that refer to resource files may use two
special tokens to supply those references. Using these tokens
rather than a direct reference to the resource provides several
advantages:
<ul>
<li>The resource can be embedded in a JAR file
<li>A resource embedded in a JAR file can be overridden by supplying
    the same resource as a regular file. This can be useful in
    debugging situations.
<li>The tokens implement semantics that would otherwise have
    to be implemented on a case-by-case basis in the harness and tests
<li>Resolution of the tokens includes an existence check with an
    unambiguous exception so that typos or packaging errors are
    easily detected.
</ul>

<p>

A token of the
form &lt;file: <code>path</code>&gt; 
is assumed to refer to a file named by <code>path</code>. The harness will search for
that file following a search path described in the next section.
If the file is found, the token is replaced by the fully qualified name
of the first occurance of the file in the search path.
Otherwise a <code>TestException</code> is thrown.

<p>

A token of the
form &lt;url: <code>path</code>&gt; 
is assumed to refer to a file named by <code>path</code> that may
be embedded in a JAR file. The harness will first search for
that file as described above. If the file is found, the token
is replaced by a file URL specifying the fully qualified path
of the file. Otherwise, the test and harness jar files are examined,
resolving the reference first relative to the location of the test
description file, then relative to the root of the test JAR file,
and finally relative to the root of the harness JAR file. If the
file is found, the token is replaced with an appropriate JAR file URL.
Otherwise, a <code>TestException</code> is thrown.

<p>

<h2>Search Path</h2>

When the harness processes the &lt;url:filename&gt; or &lt;file:filename&gt; tokens, it searches 
for <code>filename</code> along a search path defined by the <code>searchPath</code>
test property. Regardless of the value of this property, the search path will
always include ${qa.home}. In general, <code>searchPath</code> should
be defined self-referentially. For instance, it can be convenient for 
debugging purposes to modify the search path on the command line as follows:
<pre>
      -searchPath '${searchPath},/files/suitedir/src'
</pre>
which would add the <code>/files/suitedir/src</code> directory to the search path. The list
must be comma-separated. Whitespace in file and directory names are allowed. 
The search is performed relative to the base of each searchPath component,
and relative to each (component + current test description file directory)
so that short names can be used for files that are colocated with the
test description file.

<p>

<h2>ConfigurationFileSets</h2>
Each Jini test is run with a selected ConfigurationFileSet. A 
ConfigurationFileSet is a collection of compatible files used
by the activation system, services, and the test. Most of these files
are ConfigurationFiles, but the set may include other
types of files, such as keystores or property files. In the binary
distribution, all of these resources are embedded in the harness
JAR file. When a test is run,
the ConfigurationFileSet to use is identified by a user specified tag. Supported
tags include:
<ul>  
        <li> <code>jrmp</code>
        <li> <code>jeri</code>
	<li> <code>jsse</code>
	<li> <code>http</code>
	<li> <code>https</code>
	<li> <code>kerberos</code> (requires additional setup - see Appendix A)
	<li> <code>none</code>
</ul>
The set
of tags to use in a test run is specified either on the command line via the option:
<pre>
  -org.apache.river.qa.harness.configs tag1[,tag2,...]
</pre>
or in the deployment property file via the following definition:
<pre>
  org.apache.river.qa.harness.configs=tag1[,tag2,...]
</pre>
If multiple tags are specified, the same test is run successively with each configuration.
The default value is <code>none</code>. The tag is used by the harness to 
locate the root directory of the ConfigurationFileSet. These root 
directories are located at:
<pre>
     &lt;url: harness/configs/jrmp&gt;
     &lt;url: harness/configs/jeri&gt;
     &lt;url: harness/configs/jsse&gt;
     &lt;url: harness/configs/http&gt;
     &lt;url: harness/configs/https&gt;
     &lt;url: harness/configs/kerberos&gt;
</pre>
The <code>none</code> tag is a special case, indicating that configurations
are not to be used. In this case, the default values built into the
Jini components and tests are used. There is no configuration tree associated with
the <code>none</code> tag.
<p>
The files that constitute a ConfigurationFileSet are static data sources and
are intended to be reusable to minimize the number of files that need to be
supported. <code>Configuration</code> entries that must be defined dynamically
are provided as <a href="#overrides">overrides</a> when the ConfigurationFile is
loaded by the <code>ConfigurationProvider</code>. The test harness includes
built-in support for specifying some overrides, such as the service persistence
directory. A mechanism is also provided to allow tests to supply additional
overrides when a service is started.
<p>
Under each ConfigurationFileSet root directory lies a tree of 
files. Each tree has the following structure:
<pre>
 &lt;root&gt;
       /configset.properties (optional)
       /test.config
       /norm
            /norm.config
       /mercury
            /mercury.config
       ...
       <b>other Jini service config directories</b>
       ...
       /sharedgroup
            /sharedgroup.config
       /phoenix
            /phoenix.config
       /starter
            /starter.config
</pre>

For each Jini service there is a default service ConfigurationFile
(e.g. norm.config). There is also a default ConfigurationFile for the service
starter, the activation system, the activation group VM, and the administrative
service for the shared group (<code>SharedGroupImpl</code>). 
Each configuration has a default test ConfigurationFile named
<code>test.config</code> that is expected to be reusable for most tests. Tests
may specify an override for the entries in <code>test.config</code> by naming an 
optional test configuration file via the <code>testConfiguration</code> test
property, who's value would typically be defined via a &lt;url:&gt; or
&lt;file:&gt; token. When the test searches for an entry, it will first look in the file
named by this property. If the entry is not found, the default
<code>test.config</code> file is searched.

<h2>Test Properties Values</h2>

Tests for Jini services may require access to numerous configuration values.
For instance, a simple <code>JoinManager</code> test might require instantiation
of several lookup services, all possibly configured in different ways. To meet
this requirement, the test environment supports an extensive hierarchy of data
sources.  Support utilities provide easy, consistent access to the values
defined in these sources.

<p>

This hierarchy provides various levels of scope for defining test property
values. For instance, there are files that apply to all tests, files that are
accessed only for all tests for a particular component
(e.g. <code>JoinManager</code>), files that may be included by arbitrary groups
of tests, and files that are accessed only for a specific test. This makes it
possible to establish a hierarchy of default values that can be overridden at
different levels of granularity. And, of course, very simple tests can also be
written that do not directly access any configuration information.

<p>

All of the configuration information available to a test is represented by an
instance of the <code>QAConfig</code> class, which is passed to the test during
test setup. This object is constructed for a test by (logically) merging the
contents of a set of property files, the command-line arguments, and a single
test ConfigurationFile. The <code>QAConfig</code> object provides accessors for
obtaining the <code>String</code> values provided by these sources. In general,
this collection of data will be referred to as the <i>test properties</i>, even
though some of the sources are not true <code>Properties</code> objects. The set
of sources follows, in order of precedence (highest first):

<ul>
  <li>Slave properties overrides, only used when the slave test VM command line is being generated
  <li>'Dynamic' properties, which can be defined programatically by tests
  <li>The command line
  <li>System properties
  <li>The test description property file
  <li>The test ConfigurationFile
  <li>The ConfigurationFileSet property file
  <li>The deployment property file
  <li>A default property file
  <li>Defaults built into the code
</ul>

Each of these sources is described in more detail below.  Access to non-string
<code>Entries</code> provided by the test ConfigurationFile must be obtained
directly from the associated <code>Configuration</code> object, which is
available to a test via the <code>getConfiguration()</code> method of the
<code>QAConfig</code> object.

<h3>Slave Properties Overrides</h3>

In a distributed test, it may be necessary for the slave to use a local
property value in place of the value supplied by the master. These overrides
may be defined in the slave deployment properties files through the
property <code>org.apache.river.qa.harness.slaveTestOverrides</code>. The value
of this property is always obtained locally, and is a comma or space
separated list of property names who's values should also be obtained
locally.

<h3>Dynamic Properties</h3>

On rare occasions, it may be necessary for a test to define a configuration
value on the fly. The most likely case is when a value needed for a service
property cannot be predefined in a static configuration file.
<code>QAConfig</code> provides a <code>setDynamicProperty</code> method to
support this. These properties are automatically reset for each test.

<h3>Command Line</h3>

Test properties can be defined on the harness command line. Any pair of tokens
of the form "-foo bar" will be treated identically to the property definition
"foo=bar". Such a definition generally will not be defined as a system property
for the test VM, but will be accessible via the test property accessor methods
defined by <code>QAConfig</code>.

<h3>System Properties</h3>

System properties are included when searching for test property values.  Note,
however, that system properties defined when starting the harness are not
automatically inherited by the test VM. The use of system properties should be
considered an internal implementation detail, employed by the harness VM to
establish the environmental context of the test VM.  System properties should
not be directly used to configure test behavior.

<h3>Test Description File</h3>

Every test is defined by a test description properties file.  These files must
be located in the primary test JAR file identified by the <code>-testJar</code>
command-line option, and must have an extension of ".td". The
name of a test is the pathname to the test description file relative to
the root of the test Jar file.  
Test description files must contain values for the following keys:

<dl>
  <dt><code>testClass</code> 
  <dd>the name of the test implementation class. If the class is in the same directory
      as the test description file, then the unqualified class name may be used. Otherwise
      the fully qualified name must be given.
  <dt><code>testCategories</code>
  <dd>a comma-separated list of test category names
</dl>

These property values cannot be overridden or defined anywhere else.  There are
also additional keys that are associated with test descriptions, but which may
be defaulted in a more global property file:

<dl>
  <dt><code>testCodebase</code> 
  <dd>the codebase for the test
<tr>
  <dt><code>testPolicyfile</code> 
  <dd>the security policy file for the test
<tr>
  <dt><code>testClasspath</code> 
  <dd>the classpath for the test
<tr>
  <dt><code>testConfiguration</code> 
  <dd>the name of the test ConfigurationFile
<tr>
  <dt><code>testjvm</code>  
  <dd>the fully qualified path to the VM executable
<tr>
  <dt><code>testjvmargs</code>  
  <dd>options and properties to be passed to the test VM. Multiple values must be separated
      by commas. Special characters, such as a leading '-', must
      be included. Property definitions must be expressed in the usual
      form: -Dname=value. White space is not removed so that
      paths containing white space characters are supported.
<tr>
  <dt><code>testOverrideProviders</code>
  <dd>a white-space or comma separated list of override providers to
      be registered before executing the test.
<tr>
  <dt><code>testMaxRetries</code>
  <dd>an integer defining the number of times a test should be rerun on
      failure. The default value is 1. Test reruns are not performed unless the
      test property <code>org.apache.river.qa.harness.rerunFailedTests</code> is
      also defined and has the value <code>true</code>. The default value of
      this property is <code>false</code>.
</dl>

The value of <code>testConfiguration</code> is optional and would typically
be supplied as a &lturl:&gt; token referring to a ConfigurationFile included
in the primary test JAR file. This file contains entries that override or augment the
entries in the default <code>test.config</code> file for the configuration.

<p>

The test description file also supports an 'include' mechanism. If
an entry of the form 

<pre>
   include=<code>resourceName</code>
</pre>

is found, where <code>resourceName</code> is expressed as a file name
either relative to the location of the test description file, or relatiive
to the root of the test JAR file,
then the properties provided by the resource are added to the test description
entries. If an entry for 'include' is not found, then entries of the form
'include0=<code>resourceName</code>', 'include1=<code>resourceName</code>', ...,
'includeN=<code>resourceName</code>' are searched for and loaded until an entry
for <code>includeN</code> is not found. If an included key already exists in the
test description file then the include entry is
discarded.  This prevents included files from overriding entries directly
specified in the test description. If multiple includes contain values for the
same entry, higher numbered includes superceed lower numbered ones.

<h3>Test <code>Configuration</code> Object</h3>

Each test has an associated <code>Configuration</code> object that is loaded
from a test ConfigurationFile in the selected ConfigurationFileSet.  The object
may be obtained within the test by calling the <code>getConfiguration()</code>
method on the <code>QAConfig</code> object.  The <code>Configuration</code>
object associated with the test is typically used to obtain objects such as
exporters and proxy preparers, and may be passed in the constructors for
utilities such as JoinManagers. The harness also includes the
<code>Configuration</code> object in the search when resolving a test property
value. If the fully qualified entry name is the same as the test property
being searched for, and if the entry returns a <code>String</code>, then the
entry is considered a match. This makes it possible to pass values to an
individual test that are dependent on which configuration is selected.

<h3>ConfigurationFileSet Properties File</h3>

The root directory of a ConfigurationFileSet may contain a properties file named
<code>configSet.properties.</code> This file may be used to provide values that
are dependent on which ConfigurationFileSet is selected.  These values are
applied for all tests using the selected set. One use of this file is to provide
system properties for the test VM which are only appropriate for secure
configurations.

<h3>Deployment Properties File</h3>

When the harness is invoked from the command line, the name of a deployment
properties file must be provided. The example prototype for this file is located
in
<code>${qa.home}/src/org/apache/river/resources/basicDeployment.prop.</code>
in the source distribution kit.

Typically, a test suite would define additional properties which must be
added to this prototype.

<h3>Default Properties File</h3>

A default properties file is the last properties file searched to resolve a test
properties key. It is referenced via the token
<code>&lt;url:org/apache/river/qa/resources/qaDefaults.properties&gt;.</code>

<h3>Defaults in the Code</h3>

Finally, the test configuration accessors require a default value to be supplied
in the test code.  If the configuration key is not found, the default value is
returned.

<h3>Symbolic References in Test Property Values</h3> 

When a test property value is obtained from <code>QAConfig</code>, simple string
substitution is performed. If the value contains a string of the form
<code>$foo</code> or <code>${foo}</code>, then the test properties are searched
using the key <code>foo</code>. If a value for <code>foo</code> is found, then
that value replaces the original reference. Substitutions are performed
recursively.  Within a single source, a given property may only be defined
once. However, a higher precedence source can reference a lower precedence
source self-referentially.  For instance, if 'foo' was defined in
qaDefaults.properties as:

<pre>
    foo=bar
</pre>

and was then redefined in the test description file as:

<pre>
    foo=${foo} bell
</pre>

the resulting value for <code>foo</code> would be 'bar bell'. 

<p>

After all symbolic substitutions are performed, the resulting value is searched
for the following tokens:

<ul>
<li>&lt;gethost&gt;, which if found is replaced with the name of the current host, or
the IP address of the current host of the property <code>org.apache.river.qa.harness.useAddress</code>
is defined and has the value <code>true</code>.
<li>&lt;harnessJar&gt;, which if found is replaced by the fully qualified path to
the harness JAR file
<li>&lt;testJar&gt;, which if found is replaced by the fully qualified path to the test JAR file
<li>&lt;config&gt;, which if found is replaced by the configuration name being used for
the current test (i.e. jeri, jrmp, http, etc.).
<li>any tokens defined by the test suite
</ul>

Following this, the values of the &lt;url:&gt; and &lt;file:&gt; tokens are evaluated. This
ordering allows the tokens in the previous list to be embedded in these file based tokens.

<p>

For additional details on the string substitution mechanism, see <a
href=org/apache/river/harness/Resolver.html><code>org.apache.river.qa.harness.Resolver</code></a>.

<h2>Custom Security Policy Provider</h2>

The test harness kit provides a number of default policy files for tests and
for the supported Jini services. In many cases, test suite developers will find
that additional grants are required to satisfy testing requirements. Rather
than duplicating and tweaking the supplied policy files, a <code>MergedPolicyProvider</code>
is supplied in the harness that accepts multiple policy files and produces a 
policy that represents the union of the policy files. This union is not perfect,
but is considered adequate for testing purposes. For example, if policy file A
granted read access to foo and policy file B granted write access to foo, then
an access check for read,write access  to foo would still fail.
<p>
The policy provider is <code>${qa.home}/lib/mergedpolicyprovider.jar</code>
(in both the source and binary distributions) and must be installed in the extensions 
directory of the JDK used to run the test harness. On startup, the harness will
verify that the provider is loaded by the extension class loader and will exit
with an error message if this is not the case.
<p>
When the harness starts a test or service, it specifies the default policy file to use
via the normal <code>java.security.policy</code> property. If additional grants
are required, additional policies can be specified by supplying a list of
policy files (using &lt;url:&gt; or &lt;file:&gt; tokens) through the
system property <code>org.apache.river.qa.harness.policies</code> for the VM
containing the test or service. This list may be separated by commas or white space.
<p>
<b>Note:</b> due to a known bug, the grants supplied by the <code>MergedPolicyProvider</code>
are not applied to services in this release of the harness.

<h2>Trust Resources</h2>

Both the source and binary harness distributions supply a variety of trust resources.
These resources include JAAS login
configuration files, keystores, truststores, etc. Because the value of the
<code>javax.net.ssl.trustStore</code> property must refer to a file, the
trust store supplied by the harness is packaged as a separate file in
<code>${qa.home}/harness/trust/truststore</code> in both the
source and binary distributions.

<h2>Starting Jini Services</h2>

The <code>AdminManager</code> provides the following method for starting Jini
services:

<pre>
   public Object startService(String serviceName)
</pre>

where <code>serviceName</code> is a string that identifies the service to
start. This method returns the proxy for the service. <code>serviceName</code>
is used to construct a set of property names used to obtain service parameters
from the test properties.  See <a href="#admins">Service Admins</a> for details
on this mechanism.  It is possible to override some of these property values (in
the test description file, for instance) to affect the behavior of the
service. The most common overrides are defined to specify the groups and
locators used by the service.  Default property values for all of the
contributed Jini services are defined in the default property file,
<code>&lt;url:org/apache/river/qa/resources/qaDefaults.properties&gt;.</code>
By convention, the <code>serviceName</code> for a service is the name of the
public interface that the service implements. Therefore, the contributed Jini
services have the following <code>serviceNames</code>:

<pre>
      net.jini.core.lookup.ServiceRegistrar
      net.jini.lease.LeaseRenewalService
      net.jini.discovery.LookupDiscoveryService
      net.jini.event.EventMailbox
      net.jini.core.transaction.server.TransactionManager
      net.jini.space.JavaSpace
</pre>

If a test implementation requires the creation of a specialized test service,
that test service may be started with the <code>startService</code> method as
long as all of the mandatory service properties are defined, as described in <a
href="#admins">Service Admins</a>.

<h2><a name=overrides>Service <code>Configuration</code> Overrides</a></h2>

When a Jini service is started, its associated ConfigurationFile is obtained
from the ConfigurationFileSet. These are static files, so
<code>Configuration</code> values generated at run-time must be
passed as overrides. A set of overrides are passed automatically 
during startup:

<ul>
    <li>initialLookupGroups
    <li>initialLookupLocators
    <li>initialMemberGroups (only provided to lookup services)
    <li>persistenceLog
    <li>an indirect reference to the exporter to use*
</ul>

A test may also supply additional overrides to a service. The test may register
one or more instances of the
<code>org.apache.river.qa.harness.OverrideProvider</code> interface with
<code>QAConfig</code> by calling its <code>addOverrideProvider</code>
method. The <code>testOverrideProviders</code> property may also be defined to
identify a list of providers to be registered automatically before starting the
test. Whenever the test or a service is started, the set of registered override
providers is obtained and the <code>getOverrides</code> method called on
each. The string arrays returned by these override providers are merged into the
set of overrides passed to the test or service. Any such overrides that have the
same entry name as the automatically generated overrides will take precedence.

<p>

* the exporter required by an activatable service is different than that
required by a nonactivatable service. To avoid duplicating configuration files
for activatable and nonactivatable variants, a scheme was developed to allow the
specification of the appropriate exporter to use through an override. See <a
href="#configfiles">Service Configuration Files</a> for more details.

<h2>Auxiliary Services</h2>

The class servers required to support test execution are, by default,
automatically started during test setup. The activation system and any required
activation groups (or non-activatable groups) are also started if needed by
services. These auxiliary services will be automatically stopped during test
teardown.  The default behavior of <code>setup</code> in <code>QATest</code> is
to:

<ul>
<li>Start a class server for starter kit <code>-dl.jar</code> files.
<li>Start a class server for harness <code>-dl.jar</code> files
</ul>

The properties that control these auxiliary services are defined in the example
deployment properties file,
<code>${qa.home}/src/org/apache/river/qa/resources/basicDeployment.prop.</code>
supplied in the harness source distribution.

<h3>The Starter Kit Class Server</h3>

By default, the harness will automatically start a class server on port 8080 to
serve JAR files from <code>${jsk.home}/lib-dl.</code> This can be inhibited by
defining

<pre>
   org.apache.river.qa.harness.runjiniserver=false
</pre>

To change the port (for example, to 9000), define the following:

<pre>
   org.apache.river.jsk.port=9000
   org.apache.river.qa.harness.dldir.9000=${org.apache.river.jsk.jars}
</pre>

The second line is needed to support generating httpmd URLs.

<h3>The QA Class Server</h3>

By default, the harness will automatically start a class server on port 8081 to
serve JAR files from <code>${qa.home}/lib.</code> This can be inhibited by
defining

<pre>
   org.apache.river.qa.harness.runkitserver=false
</pre>

To change the port (for example, to 9001), define

<pre>
   org.apache.river.qa.port=9001
   org.apache.river.qa.harness.dldir.9001=${org.apache.river.qa.jars}
</pre>

The second line is needed to support generating httpmd URLs.

<h3>The Activation System</h3>

The first time the <code>AdminManager</code> is called to start an activation
group on a master or slave host, an activation system will be started
automatically to support the group.  The harness by default will start
phoenix. For more information, see the JavaDoc for
<code>ActivationSystemAdmin</code>. If harness management of the activation
system must be disabled, the following may be defined:

<pre>
   org.apache.river.qa.harness.runactivation=false
</pre>

This would be done only in unusual debugging situations.

<h3>The Global Shared Group</h3>

The first time the <code>AdminManager</code> is called to start an activatable
service on a master or slave host, an activation group will automatically
be started to support the service (which in turn will cause the activation
system to be started).  By default, the harness creates a shared activation group
that is used for all other activatable service started by the same
<code>AdminManager</code>.  This can be inhibited by defining

<pre>
   org.apache.river.qa.harness.shared=false
</pre>

which will cause each service to run in a private activation group.

<h2>Test Logging</h2>

The harness merges the output generated by the activation system and class
servers into the logging output from the test. It also merges the output
generated from slave tests into the logging output stream of the master test
unless the following is defined:

<pre>
  org.apache.river.qa.harness.slavepipe=false
</pre>

This typically is only done for debug/demo purposes.

<p>

The test harness configuration files are set up to treat the system property
<code>java.util.logging.config.file</code> specially.  If a logging properties
file is specified on the command line when starting the test harness on a master
or slave, then that same logging property will automatically be set on the test
and service VMs started by the master or slave harness.

<p>

Test output is generated by calls to the Java logging API to a logger named
<code>org.apache.river.qa.harness.</code> A custom <code>ReportHandler</code>
forwards all log records to <code>System.out</code>.  A custom formatter will
optionally prepend the record with the abbreviated source (last class name
token and method name) and level indicator.  If the test is running distributed,
then the name of the host on which the output was generated will also be
prepended. Timestamps are generated at intervals, specified by the logging
property <code>org.apache.river.qa.harness.HarnessFormatter.timeinterval</code>.
If a log message is generated and the number of seconds specified by this
property have elapsed since the last timestamp, a new timestamp is generated
on a separate line. The default value is ten seconds. If this property
is defined with a value of zero, the timestamp is generated and prepended
on every logging record.

<p>

There are four boolean logging properties that can be defined to control the
display of the source, level, timestamp, and host info:

<pre>
   org.apache.river.qa.harness.HarnessFormatter.showtime
   org.apache.river.qa.harness.HarnessFormatter.showsource
   org.apache.river.qa.harness.HarnessFormatter.showlevel
   org.apache.river.qa.harness.HarnessFormatter.showhost
</pre>

These must be defined in the logging properties file rather than in the harness
configuration files. If undefined these properties default to <code>true</code>.

<p>

A reference to the <code>org.apache.river.qa.harness</code> logger is provided
by <code>QATest</code> via the static protected field <code>logger</code>.

<h2>Test Timeouts</h2>

The test harness can be configured to timeout a test after a fixed period
of time. The definition:

<pre>
   org.apache.river.qa.harness.timeout=&lt;val&gt;
</pre>

where <code>&lt;val&gt;</code> is an integer, will cause the test VM process
to be interrupted <code>val</code> seconds after the test was started.
The default value of <code>val</code> is zero, which disables timeouts.

<h2>Supporting httpmd Codebases</h2>

When a test is configured for security, test and service codebases will
automatically be converted to httpmd URLs. This behavior is globally controlled
by the test property <code>org.apache.river.qa.harness.integrityhash</code>.  If
this value is defined and has any value other than "none", then any http URL in
a test or service codebase will automatically be converted to an httpmd URL,
using the value of the <code>integrityhash</code> property as the name of the
hashing function. If the value of this property consists of multiple
comma-separated tokens, then each token is assumed to be the name of a hashing
function, and the function to use is chosen randomly for each httpmd URL
generated.  This property would typically be defined in the ConfigurationFileSet
property file, located at
<code>&lt;url:harness/configs/*/configSet.properties&gt;.</code> This global
flag can be overridden on a per-service basis by defining a value for the
service property named <code>integrityhash</code>.

<p>

In order to perform the conversion, it is necessary to know the document
directory associated with the http URL. To obtain this, a test property
<code>org.apache.river.qa.harness.dldir.&lt;port&gt;</code> must be defined where
&lt;port&gt; is the port number associated with the URL.

<h2>API Overview</h2>

This section summarizes the classes and methods most often referenced by test
implementation code:

<h4>org.apache.river.qa.harness.Test</h4>

All tests must implement the <a
href=org/apache/river/harness/Test.html><code>org.apache.river.qa.harness.Test</code></a>
interface:

<pre>
    public interface Test {
      public void setup(QAConfig config) throws Exception;
      public void run() throws Exception;
      public void teardown();
    }
</pre>

All three of these methods are called by the harness in the order listed, unless
<code>setup</code> throws an exception. See
<code>org.apache.river.qa.harness.QATest</code> for additional details on how the
harness interacts with implementations of this interface.  A test which does not
require the features provided by <code>QATest</code> could implement this
interface directly. This document is written with the assumption that test
implementations will extend <code>QATest</code>.

<h4>org.apache.river.qa.harness.Admin</h4>

The <code>Admin</code> interface is implemented by objects that are used to
control services. Several implementations of this interface are included with
the test harness, as described later. Three methods are defined:

<pre>
      public void start() throws RemoteException, TestException;
      public void stop() throws RemoteException;
      public Object getProxy();
</pre>

After the <code>start</code> method is called to start the service,
the <code>getProxy</code> method may be called to obtain its proxy.
Also, <code>start</code> and <code>stop</code> should only be called
once; the behavior of additional calls is undefined.

<h4>org.apache.river.qa.harness.AdminManager</h4>

<code>AdminManager</code> acts as a factory for service admins, and supports
orderly startup/shutdown of services used by a test. Methods are provided for
starting and stopping services, and for obtaining the admin of a service for
those rare cases where access to the admin is necessary. The most commonly
called methods of this class are:
<p>
<table summary="commonly called AdminManager methods">
<tr valign=top>
  <td><code>startService(String serviceName)</code>
  <td>starts a jini service, as described above
<tr valign=top>
  <td><code>startLookupService()</code>
  <td>calls startService("net.jini.core.lookup.ServiceRegistrar");
<tr valign=top>
  <td><code>getAdmin(Object proxy)</code>
  <td>returns the admin associated with a given service proxy
</table>
<p>
In addition, the <code>destroyAllServices()</code> method is always called by
the <code>teardown</code> method implemented by <code>QATest</code>.
<code>AdminManager</code> maintains a table of all the services that were
started with the <code>startLookupService</code> and <code>startService </code>
methods. The <code>destroyAllServices</code> method uses the entries in this
table to perform an ordered shutdown of the services. Because the
<code>teardown</code> method implemented by the <code>QATest</code> base class
always calls <code>destroyAllServices</code>, it is generally unnecessary for a
test to call explicitly any of the destroy methods provided by
<code>AdminManager.</code>

<p>

Tests rarely need to directly access the admin object for a service, since the
<code>AdminManager</code> object mediates most service related
activity. However, occasionally it may be necessary to obtain a service admin in
order to obtain information about the parameters that were used to start the
service.

<h4>org.apache.river.qa.harness.QAConfig</h4>

<code>QAConfig</code> exposes a rather large number of methods. However, test
writers typically call only a small subset of them, specifically accessors of
the form

<pre>
  get&lt;type&gt;ConfigVal(key, default)
</pre>

which obtains a value of a test property interpreted as &lt;type&gt;. These
methods are used by tests that are written to access property values to control
test behavior. The set consists of:

<p>
<code>
<table summary="QAConfig test properties value accessors">
<tr>
  <td>public <td>String <td>getStringConfigVal(String key, String default)
<tr>
  <td>public <td>int    <td>getIntConfigVal(String key, int default)
<tr>
  <td>public <td>float  <td>getFloatConfigVal(String key, float default)
<tr>
  <td>public <td>double <td>getDoubleConfigVal(String key, double default)
<tr>
  <td>public <td>long   <td>getLongConfigVal(String key, long default)
<tr>
  <td>public <td>boolean<td>getBooleanConfigVal(String key, boolean default)
</table>
</code>
<p>

<h4> org.apache.river.qa.harness.QATest</h4>

This base class is inherited by most tests. It is declared to implement the
<code>Test</code> interface, and provides concrete implementations of the
<code>setup</code> and <code>teardown</code> methods. Subclasses must implement
the abstract

<pre>
    public void run() throws Exception
</pre>

method. This method provides the body of the test. A normal return indicates a
successful test. An exception return indicates test failure*.

<p>

Optionally, the test implementation may override two additional methods:

<pre>
   public void setup(QAConfig config) throws Exception
   public void teardown()
</pre>

<code>setup</code> is called before the <code>run()</code> method to perform any
pre-run setup, such as starting required services. Because the default
implementation starts the class servers, it is important that overrides of this
method call <code>super.setup(config)</code> before starting any services. The
<code>teardown</code> method is called by the harness after the
<code>run()</code> method returns, or after <code>setup</code> is called if
<code>setup</code> throws an exception. The default <code>teardown</code>
implementation will stop any services started as a result of
calling the <code>startService</code> method; it will also shut down the shared
groups, the activation system, and any class servers which were started. As a
result, it is generally unnecessary to override the default
implementation. However, if the test class implementation overrides
<code>teardown,</code> the superclass <code>teardown</code> method should be
called to ensure that the superclass cleanup code is executed. Exceptions thrown
by <code>teardown</code> are silently ignored by the harness.

<p>

<code>QATest</code> provides the accessor:

<pre>
   public QAConfig getConfig()
</pre>

which returns the <code>QAConfig</code> object passed in the <code>setup</code>
call. 

<p>

Tests written for the test harness must either extend <code>QATest</code> or
implement the <code>Test</code> interface, and must provide a no-arg
constructor.
<p>

* The harness supports the ability to register <code>FailureAnalyzers</code>
with tests which can inspect the exception and determine the pass/fail
status of a test. However, there are no analyzers implemented at this
time, so exceptions are always treated as failures. See the JavaDoc for
the <code>FailureAnalyzer</code> interface for more details.


<h4>org.apache.river.qa.harness.TestException</h4>

<code>TestException</code> is thrown by a test to signal a failure. In most
cases, unexpected exceptions (both checked and unchecked) are not caught by
tests and are also interpreted as test failures. Test writers are discouraged
from catching exceptions other than those which are expected and which
result from correct behavior of the item under test.

<h2>Running a Test</h2>

To run the harness, at least two JAR files must be included in the classpath:

<pre>
        ${qa.home}/lib/jiniharness.jar
</pre>

is the JAR file containing the harness code and resources, and

<pre>
        ${jsk.home}/lib/jsk-platform.jar
</pre>

is the starter kit platform that is typically included in the classpath of 
Jini clients and services.

<p>

The user must also specify the name of a deployment properties file on the command line
that defines installation values, such as the value of
<code>${qa.home}.</code> A prototype of this file is available at
<code>${qa.home}/src/org/apache/river/qa/resources/basicDeployment.prop</code> 
in the source distribution. 
The user must also specify the name of the primary test suite JAR file via the
command-line option <code>-testJar foo.jar</code>. In this example, <code>foo.jar</code> contains the
test description files for the tests making up the suite.
The user must also specify a list of categories or specific tests to run.
For the following examples, assume the user has placed a modified version of
this file in <code>/tmp/myHarness.prop.</code> Also, assume the starter kit has been
installed in <code>/files/jini2_1</code>, the harness kit has been installed
in <code>/files/jiniqa2_1_harness</code>, and the test suite is installed in <code>/files/testsuite</code>,
with the primary JAR file in <code>/files/testsuite/lib/tests.jar. </code>

<p>

To specify a set of test categories to run, use the <code>-categories</code>
option, for example:

<pre>
  java -cp /files/jiniqa2_1_harness/lib/jiniharness.jar:/files/jini2_1/lib/jsk-platform.jar \
       org.apache.river.qa.harness.QARunner \
       /tmp/myharness.prop \
       -testJar /files/testsuite/lib/tests.jar \
       -categories joinmanager,javaspace
</pre>

This would limit test execution to those tests whose test descriptions included
either <code>joinmanager</code> or <code>javaspace</code> in their definitions
of <code>testCategories</code>. The configuration used would be
<code>none</code> unless the value of <code>org.apache.river.harness.configs</code>
had been modified in /tmp/myharness.prop.

<p>

To specify an explicit list of tests to execute, list them after
the <code>-tests</code> option. For example,

<pre>
  java -cp /files/jiniqa2_1_harness/lib/jiniharness.jar:/files/jini2_1/lib/jsk-platform.jar \
       org.apache.river.qa.harness.QARunner \
       /tmp/myHarness.prop \
       -testJar /files/testsuite/lib/tests.jar \
       -tests org/apache/river/test/spec/joinmanager/EqualsTest
</pre>

This would execute only the hypothetical joinmanger <code>EqualsTest</code> test. The
following command line would
run this test using the jeri ConfigurationFileSet:

<pre>
  java -cp /files/jiniqa2_1_harness/lib/jiniharness.jar:/files/jini2_1/lib/jsk-platform.jar \
       org.apache.river.qa.harness.QARunner \
       /tmp/myHarness.prop \
       -testJar /files/testsuite/lib/tests.jar \
       -tests org/apache/river/test/spec/joinmanager/EqualsTest \
       -org.apache.river.qa.harness.configs jeri
</pre>

The <code>-tests</code> argument is optional, and if present must be followed by
a comma-separated list of test description file names specified 
relative to the root of the primary test suite JAR file. This identifies the set of
tests to place in the run list, which may be additionally filtered by
category. If omitted, all tests are placed in the run list.

<p>

The <code>-categories</code> argument is optional, and if present must be
followed by a comma-separated list of test categories. When the run list is
processed, tests which do not belong to one of the specified categories are
discarded from the list. If omitted no category filtering is done.

<p>
One or both of these options must be specified.

<h2><a name="admins">Service Admins</a></h2>

Admins are an abstraction for controlling services.  All admins implement at
least two methods: <code>start</code> and <code>stop</code>. There are seven
admins provided with the harness.  They are:

<table summary="supported Admin implementations">
<tr>
  <td><a href=org/apache/river/qa/harness/ActivatableServiceStarterAdmin.html>
      <code>ActivatableServiceStarterAdmin</code></a>
  <td>manages any activatable service compatible with 
      <code>org.apache.river.start.ServiceDescriptor</code>.
<tr>
  <td><a href=org/apache/river/qa/harness/NonActivatableServiceStarterAdmin.html>
      <code>NonActivatableServiceStarterAdmin</code></a>
  <td>manages any non-activatable service compatible with 
      <code>org.apache.river.start.ServiceDescriptor</code>.
<tr>
  <td><a href=org/apache/river/qa/harness/RunningServiceAdmin.html>
      <code>RunningServiceAdmin</code></a> 
  <td>manages any service which is already running and registered in 
      a lookup service.
<tr>
  <td><a href=org/apache/river/qa/harness/SharedGroupAdmin.html>
      <code>SharedGroupAdmin</code></a>
  <td>manages a shared activation group
<tr>
  <td><a href=org/apache/river/qa/harness/ActivationSystemAdmin.html>
      <code>ActivationSystemAdmin</code></a>
  <td> manages an activation system
<tr>
  <td><a href=org/apache/river/qa/harness/ClassServerAdmin.html>
      <code>ClassServerAdmin</code></a>
  <td>manages an in-process class server
<tr>
  <td><a href=org/apache/river/qa/harness/RemoteServiceAdmin.html>
      <code>RemoteServiceAdmin</code></a>
  <td>manages a remote service - used internally when running distributed
</table>

In addition to the start/stop methods, these admins all include accessors for
obtaining their initial service parameters. Examples of these accessors
include <code>getCodebase</code>, <code>getClasspath</code>,
<code>getPolicyFile</code>, etc. The <code>ActivatableServiceStarterAdmin</code>
also provides methods for obtaining the <code>ActivationGroup</code> and
<code>ActivationID</code> of the service.

<p>

In general, it is not necessary for tests to instantiate or access these admins.
<code>AdminManager</code> provides utility methods which start/stop services and
manage these admins transparently.

<p>

Services require a variety of parameters to be specified when they are
started. These parameters are generated by the admin based on values obtained
from the test properties.  When an admin is constructed, it must be provided
with a <code>serviceName</code> that is used to search <code>QAConfig</code>
for configuration values. By convention, this identifier is formatted as the
fully qualified name of the service interface or class to be managed, for
example:

<pre>
  net.jini.discovery.LookupDiscoveryService
</pre>

Some of these properties refer to files or resources embedded in the harness
or test JAR files. Definitions of these property values should use the appropriate
token type.
 
<p>

The <code>serviceName</code> is used as a prefix string for generating service
property names. The admins accept an instance counter, which is a zero based
integer that can be used when multiple instances of the same service are needed
for a test. The counter is used as a suffix when generating property names. It
is not necessary for test code to manage this counter; the support methods in
<code>AdminManager</code> maintain counters for every service. A set of
well-known service identifiers are used to generate the set of property names
associated with a service. These well-known identifiers, categorized by admin
type, are:

<h3 align=center><code>ActivatableServiceStarterAdmin</code></h3>
<table summary="supported service properties for ActivatableServiceStarterAdmin">
<tr align=left>
 <th>
 <th>Identifier
 <th>Usage
<tr valign=top>
  <td>
  <td><code>type</code>
  <td>a mandatory property having the value "activatable".
<tr valign=top>
  <td>
  <td><code>impl</code>
  <td>the implementation class
<tr valign=top>
  <td>
  <td><code>host</code>
  <td>if defined and running distributed, the master or slave host for the service. Valid values are:
<dl>
    <dt><code>master</code>    
        <dd> always run on the master host

    <dt><code>slave</code>     
        <dd>modify the selection policy to always select a slave by converting
            roundrobin to remoteroundrobin or random to remoterandom

    <dt><code>slaveN</code>    
        <dd>where "N" is an integer,  use the Nth entry in the host list (modulo
            the host list size). If the index is 0, it is reset to 1.

    <dt><code>name</code>	
        <dd>where <code>name</code> is the name of the master or slave host.
            If <code>name</code> is not in the list, a 
            <code>TestException</code> is thrown.
</pre>
      if this property is undefined, the default selection policy is used.
<tr valign=top>
  <td>
  <td><code>classpath</code>
  <td>the service classpath
<tr valign=top>
  <td>
  <td><code>codebase</code>
  <td>the service codebase
<tr valign=top>
  <td>
  <td><code>policyfile</code>
  <td>the service security policy file
<tr valign=top>
  <td>
  <td><code>component</code>
  <td>the component name to use when constructing entry names for entries
      in the service <code>Configuration</code>. For example, reggie has a
      value of <code>"org.apache.river.reggie"</code> for this property. This
      property must be defined if the 
      tojoin or membergroups properties are defined, or if log property has any
      value other than "none".
<tr valign=top>
  <td>
  <td><code>log</code>
  <td>a token used in constructing the log directory path. If undefined,
      a value of "log" is assumed. If set to "none", no persistence
      log override definition is generated. The component property
      must be defined unless log is set to "none".
<tr valign=top>
  <td>
  <td><code>tojoin</code>
  <td>for Jini services, the groups/locators to join. If this property
      is defined, then the component property must also be defined
<tr valign=top>
  <td>
  <td><code>membergroups</code>
  <td>for lookup services, the member groups. If this property is defined,
      then the component property must also be defined.
<tr valign=top>
  <td>
  <td><code>port</code>
  <td>the multicast port (lookup services only)
<tr valign=top>
  <td>
  <td><code>serviceConfiguration</code>
  <td>the name of the service configuration file relative to the
      root directory of the ConfigurationFileSet. If the value of
      this property is "-", then no <code>ConfigurationFile</code>
      is loaded, but command-line overrides are still generated.
<tr valign=top>
  <td>
  <td><code>starterConfiguration</code>
  <td>the name of the service starter configuration file relative to the
      root directory of the ConfigurationFileSet directory. If the value of
      this property is "-", then no <code>ConfigurationFile</code>
      is loaded.
<tr valign=top>
  <td>
  <td><code>serverjvmargs</code>
  <td>any options or properties to pass to the service VM, separated by commas.
      Any special characters, such as a leading '-', must be included. Properties
      must be defined using standard command line syntax, i.e. "-Dfoo=bar". 
      White space is not removed so that paths containing white space are supported.
<tr valign=top>
  <td>
  <td><code>serverjvm</code>
  <td>the absolute path name of the VM to use to run the service. The
      default value is the same VM used to run the test.
<tr valign=top>
  <td>
  <td><code>activationhost</code>
  <td>The host name of the activation system to contact. If undefined
      the local host is contacted.
<tr valign=top>
  <td>
  <td><code>activationport</code>
  <td>The port number of the activation system to contact. If undefined or
      0, the default activation port is used.
<tr valign=top>
  <td>
  <td><code>integrityhash</code>
  <td>the name of the hashing algorithm to use to generate httpmd URLs.
      If defined and having a value other than "none", http URLs in
      codebases are automatically converted to httpmd URLs using the
      hashing algorithm named by this property. This value overrides
       the value defined by the global property 
      <code>org.apache.river.qa.harness.integrityhash</code> and has the
      same semantics for supporting multiple values.
<tr valign=top>
  <td>
  <td><code>restart</code>
  <td>the value of the <code>restart</code> parameter to pass to the
      activation system when the service is registered. If undefined,
      the default value is <code>true</code>.
<tr valign=top><td><td><td>
</table>

<code>serverjvmargs</code> is unused if the activatable service is run in the
global shared group. However, if the global group is disabled, then the
<code>ActivatableServiceStarterAdmin</code> will create a private shared group
for the service and the <code>serverjvmargs</code> defined for the service will
be merged with those for the private shared group VM.

<h3 align=center><code>NonActivatableServiceStarterAdmin</code></h3>
<table summary="supported service properties for NonActivatableServiceStarterAdmin">
<tr align=left>
 <th>
 <th>Identifier
 <th>Usage
<tr valign=top>
  <td>
  <td><code>impl</code>
  <td>the implementation class
<tr valign=top>
  <td>
  <td><code>type</code>
  <td>a mandatory property having the value "transient" or "persistent"
<tr valign=top>
  <td>
  <td><code>classpath</code>
  <td>the service classpath
<tr valign=top>
  <td>
  <td><code>codebase</code>
  <td>the service codebase
<tr valign=top>
  <td>
  <td><code>policyfile</code>
  <td>the service security policy file
<tr valign=top>
  <td>
  <td><code>component</code>
  <td>the component name to use when constructing entry names for entries
      in the service <code>Configuration</code>. For example, reggie has a
      value of <code>"org.apache.river.reggie"</code> for this property. This
      property must be defined if the 
      tojoin or membergroups properties are defined, or if log property has any
      value other than "none".
<tr valign=top>
  <td>
  <td><code>log</code>
  <td>a token used in constructing the log directory path. If undefined,
      a value of "log" is assumed. If set to "none", no persistence
      log override definition is generated. The component property
      must be defined unless log is set to "none".
<tr valign=top>
  <td>
  <td><code>tojoin</code>
  <td>for Jini services, the groups/locators to join. If this property
      is defined, then the component property must also be defined
<tr valign=top>
  <td>
  <td><code>membergroups</code>
  <td>for lookup services, the member groups. If this property is defined,
      then the component property must also be defined.
<tr valign=top>
  <td>
  <td><code>port</code>
  <td>the multicast port (lookup services only)
<tr valign=top>
  <td>
  <td><code>serviceConfiguration</code>
  <td>the name of the service configuration file relative to the
      root directory of the ConfigurationFileSet directory
<tr valign=top>
  <td>
  <td><code>starterConfiguration</code>
  <td>the name of the service starter configuration file relative to the
      root directory of the ConfigurationFileSet directory
<tr valign=top>
  <td>
  <td><code>serverjvm</code>
  <td>the absolute path name of the VM to use to run the service. The
      default value is the same VM used to run the test.
<tr valign=top>
  <td>
  <td><code>serverjvmargs</code>
  <td>any options or properties to pass to the service VM, separated by commas.
      Any special characters, such as a leading '-', must be included. Properties
      must be defined using standard command line syntax, i.e. "-Dfoo=bar".
      White space is not removed so that paths containing white space are supported.
<tr valign=top>
  <td>
  <td><code>integrityhash</code>
  <td>the name of the hashing algorithm to use to generate httpmd URLs.
      If defined and having a value other than "none", http URLs in
      codebases are automatically converted to httpmd URLs using the
      hashing algorithm named by this property. This value overrides
       the value defined by the global property 
      <code>org.apache.river.qa.harness.integrityhash</code> and has the
      same semantics for supporting multiple values.
<tr valign=top><td><td><td>
</table>

Note that this admin supports both persistent and nonpersistent services.
If the <code>type</code> property is "transient", then the nonpersistent
service is started and the value of the <code>log</code> property
is ignored. If <code>type</code> is "persistent", the persistent
variant is started. 

<h3 align=center><code>RunningServiceAdmin</code></h3>

<table summary="supported service properties for RunningServiceAdmin">
<tr align=left>
 <th>
 <th>Identifier
 <th>Usage
<tr valign=top>
  <td>
  <td><code>type</code>
  <td>a mandatory property having the value "running"
<tr valign=top>
  <td>
  <td><code>impl</code>
  <td>a mandatory property providing the name of the service class to locate
<tr valign=top>
  <td>
  <td><code>tojoin</code>
  <td>a mandatory property providing the set of groups and locators to be 
      used to look up the service
<tr valign=top><td><td><td>
</table>
Note that this admin is not used by any test, and the implementation
of this admin has not itself been tested.

<h3 align=center><code>SharedGroupAdmin</code></h3>

<table summary="supported service properties for SharedGroupAdmin">
<tr align=left>
 <th>
 <th>Identifier
 <th>Usage
<tr valign=top>
  <td>
  <td><code>type</code>
  <td>a mandatory property having the value "group"
<tr valign=top>
  <td>
  <td><code>impl</code>
  <td>the implementation class of the shared group
<tr valign=top>
  <td>
  <td><code>classpath</code>
  <td>the shared group classpath
<tr valign=top>
  <td>
  <td><code>codebase</code>
  <td>the shared group codebase
<tr valign=top>
  <td>
  <td><code>policyfile</code>
  <td>the policy file for the shared group VM
<tr valign=top>
  <td>
  <td><code>serverjvmargs</code>
  <td>any options or properties to pass to the service VM, separated by commas.
      Any special characters, such as a leading '-', must be included. Properties
      must be defined using standard command-line syntax, i.e. "-Dfoo=bar". 
      White space is not removed so that paths containing white space are supported.
<tr valign=top>
  <td>
  <td><code>activationhost</code>
  <td>The host name of the activation system to be contacted. If undefined,
      the local host is contacted.
<tr valign=top>
  <td>
  <td><code>activationport</code>
  <td>The port number of the activation system to be contacted. If undefined or
      0, the default activation port is used.
<tr valign=top>
  <td>
  <td><code>implPrefix</code>
  <td>the <code>serviceName</code> identifying the administrative
      service to load into the shared group
<tr valign=top><td><td><td>
</table>
Note that there is no property to specify the shared group persistence
log. <code>SharedGroupAdmin</code> always generates a reference to a
unique log directory in the default temp directory.

<h3 align=center><code>ActivationSystemAdmin</code></h3>

<table summary="supported service properties for ActivationSystemAdmin">
<tr align=left>
 <th>
 <th>Identifier
 <th>Usage
<tr valign=top>
  <td>
  <td><code>type</code>
  <td>a mandatory property having the value "rmid" or "phoenix"
<tr valign=top>
  <td>
  <td><code>policyfile</code>
  <td>the security policy file for the activation system
<tr valign=top>
  <td>
  <td><code>codebase</code>
  <td>the codebase for the activation system
<tr valign=top>
  <td>
  <td><code>log</code>
  <td>the token used to generate the persistence directory name
<tr valign=top>
  <td>
  <td><code>logdir</code>
  <td>the activation system log directory name token
<tr valign=top>
  <td>
  <td><code>serverjvmargs</code>
  <td>any options or properties to pass to the service VM, separated by commas.
      Any special characters, such as a leading '-', must be included. Properties
      must be defined using standard command-line syntax, i.e. "-Dfoo=bar". 
      White space is not removed so that paths containing white space are supported.
<tr valign=top><td><td><td>
</table>

<h3 align=center><code>ClassServerAdmin</code></h3>

<table summary="supported service properties for ClassServerAdmin">
<tr align=left>
 <th>
 <th>Identifier
 <th>Usage
<tr valign=top>
  <td>
  <td><code>type</code>
  <td>a mandatory parameter having the value "classServer"
<tr valign=top>
  <td>
  <td><code>impl</code>
  <td>a mandatory parameter providing the name of the server class to 
      instantiate
<tr valign=top>
  <td>
  <td><code>port</code>
  <td>the TCP port the server is to use (default = 8080)
<tr valign=top>
  <td>
  <td><code>dir</code>
  <td>a mandatory parameter providing the directory from which JAR files are
      to be served
<tr valign=top>
  <td>
  <td><code>serverjvmargs</code>
  <td>additional options to supply to the class server. The only
      supported values are <code>-trees</code> and <code>-verbose</code>.
      Any properties specified are ignored since the class servers run
      in the test VM.
</table>

In addition there is a <code>RemoteServiceAdmin</code> implementation
which is used internally to support communications with <code>Admin</code>s
on slave systems. There are no identifiers exposed for the admin.

<h2>Service Property Resolution</h2>

<p>The values of some service properties may have a type dependency.  A likely
example is the implementation class, which differs for activatable and
non-activatable implementations. Service properties may be qualified by
appending the type value. For instance, for the hypothetical Jini service
<code>net.jini.FooInterface</code>, consider the following definitions:

<pre>
   net.jini.FooInterface.impl.activatable=org.apache.river.foo.FooActImpl
   net.jini.FooInterface.impl.transient=org.apache.river.foo.FooNonActImpl
   net.jini.FooInterface.impl.persistent=org.apache.river.foo.FooNonActImpl
   net.jini.FooInterface.codebase=${jsk.home}/lib-dl/foo-dl.jar
</pre>

If the value of <code>net.jini.FooInterface.type</code> is "activatable" then
all attempts to resolve any service property value for net.jini.FooInterface
will first search for the ".activatable" variant. If not found, then the
unqualified variant will be searched for. For the example above, the search for
<code>impl</code> would return <code>org.apache.river.foo.FooActImpl</code>, and the
search for <code>codebase</code> would return
<code>${jsk.home}/lib-dl/foo-dl.jar</code>. However, if
<code>net.jini.FooInterface.type</code> is "persistent", then the search for
<code>impl</code> would return <code>org.apache.river.foo.FooNonActImpl</code>, and
the search for <code>codebase</code> would return
<code>${jsk.home}/lib-dl/foo-dl.jar</code>. When overriding the
definition of a service property, it is therefore important to override all
variants for that property. Overriding only the unqualified definition will
result in incorrect behavior if any variants are defined elsewhere.

<p>

The best way to understand the generation and use of service property names is
through an example.  Assume that the following call was made for the
third time in the same test:

<pre>
  manager.startService("net.jini.discovery.LookupDiscoveryService");
</pre>

where <code>manager</code> is an instance of <code>AdminManager</code>. Since
<code>AdminManager</code> manages the instance counter automatically, it will
initially attempt to use a value of 2 when constructing property names. The
<code>startService</code> method would initially look for the following set of
configuration values (assuming an <code>ActivatableServiceStarterAdmin</code> is
used):

<pre>
  net.jini.discovery.LookupDiscoveryService.impl.2
  net.jini.discovery.LookupDiscoveryService.classpath.2
  ...
  ...
</pre>

Any configuration values found by searching with these names would be used. If
any of these names were not found, then the instance count would be decremented
and a search using the unresolved names would be repeated:

<pre>
  net.jini.discovery.LookupDiscoveryService.classpath.1
  net.jini.discovery.LookupDiscoveryService.log.1
  ...
  ...
</pre>

This process is repeated until all names are resolved, or until
the instance count reaches zero (a search with value zero is done if
necessary). If any names are still unresolved, then the
instance count is discarded and a final search is done:

<pre>
  net.jini.discovery.LookupDiscoveryService.classpath
  net.jini.discovery.LookupDiscoveryService.codebase
  ...
  ...
</pre>
This makes it easy to define a set of default values, and then to
specify overrides on a per-instance basis.
<p>
The type of admin created to manage a service is based on the 
value of the services <code>type</code> property:

<p>
<table summary="mapping of service type to admin created">
<tr>
  <th align=left>Value
  <th>
  <th align=left>Admin Created

<tr>
  <td><code>group</code>
  <td>
  <td><code>SharedGroupAdmin</code>
<tr>
   <td><code>rmid</code>
  <td>
   <td><code>ActivationSystemAdmin</code>
<tr>
   <td><code>phoenix</code>
  <td>
   <td><code>ActivationSystemAdmin</code>
<tr>
   <td><code>classServer</code>
  <td>
   <td><code>ClassServerAdmin</code>
<tr>
   <td><code>running</code>
  <td>
   <td><code>RunningServiceAdmin</code>
<tr>
   <td><code>transient</code>
  <td>
   <td><code>NonActivatableServiceStarterAdmin</code> 
<tr>
   <td><code>persistent</code>
  <td>
   <td><code>NonActivatableServiceStarterAdmin</code> 
<tr>
   <td><code>activatable</code>
  <td>
   <td><code>ActivatableServiceStarterAdmin</code>
</table>
<p>

if <code>type</code> is undefined or has a value not represented in this table,
a <code>TestException</code> is thrown. If a slave host is used for the
service, then an admin of the specified type is created on the slave host,
and a <code>RemoteServiceAdmin</code> is created in the master host
to communicate with it. This behavior is transparent to tests.

<a name="configfiles"><h2>Service ConfigurationFiles</h2></a>

The ConfigurationFiles for services must follow a few conventions
to support the use of standard overrides provided by the harness
and default proxy preparers expected by the harness. Each file
should contain the following set of well-known entries:
<table summary="exporter entries required by the service starter code">
<tr>
  <td valign=top> <code>exporter.name</code>
  <td valign=top>accessed by the harness to obtain the name of the service exporter
<tr>
  <td valign=top> <code>exporter.activatableExporter</code>
  <td valign=top>defines the exporter for the activatable service
<tr>
  <td valign=top> <code>exporter.transientExporter</code>
  <td valign=top>defines the exporter for the nonactivatable, nonpersistent service
<tr>
  <td valign=top> <code>exporter.persistentExporter</code>
  <td valign=top>defines the exporter for the nonactivatable, persistent service
</table>
<p>
An example ConfigurationFile for norm (imports omitted)  might look like:
<pre>
  exporter {
        name = "org.apache.river.norm.exporter";
        activatableExporter = new JrmpExporter((ActivationID) $data, 0);
        transientExorter = new JrmpExporter();
        persistentExporter = new JrmpExporter();
  }

  org.apache.river.norm {
   [standard norm entries, see the javadoc for org.apache.river.norm]
  }
</pre>
In order to identify the exporter to use, the harness obtains the 
<code>exporter.name</code> entry and uses it to build an override which
indirectly points to the exporter to use. For the activatable variant, 
the resulting override would be
<pre>
   "org.apache.river.norm.exporter=exporter.activatableExporter"
</pre>
When norm obtains the entry for <code>org.apache.river.norm.exporter</code>,
it will access <code>exporter.activatableExporter</code> which returns the
activatable exporter variant.

<h2>User-Specified Test Properties</h2>

The user must specify a deployment properties file on the command line used to run the
harness. This file defines installation specific values and a small number of
configurable parameters, such as timeouts. The prototype for this file is
included with the harness at
<code>${qa.home}/src/org/apache/river/qa/resources/basicDeployment.prop.</code>
Properties defined in this file include:

<table summary="mandatory and optional user supplied properties">
<tr valign=top>
  <td><code>jsk.home</code> 
  <td>

      the installation directory of the starter kit. This value is
      mandatory, and must be specified as an absolute path.

<tr valign=top>
  <td><code>qa.home</code> 
  <td>

      the installation directory of the QA 'kit'. This value is
      mandatory, and must be specified as an absolute path.

<tr valign=top>
  <td><code>org.apache.river.jsk.port</code> 
  <td>

      the HTTP port for downloading starter kit classes. This parameter
      is optional, and has the default value 8080.

<tr valign=top>
  <td><code>org.apache.river.qa.harness.dldir.8080</code> 
  <td>

      The download directory for the class server at port 8080.
      This is needed to support generating httpmd URLs.

<tr valign=top>
  <td><code>org.apache.river.qa.port</code> 
  <td>

      the HTTP port for downloading QA classes. This parameter is optional,
      and has the default value 8081.

<tr valign=top>
  <td><code>org.apache.river.qa.harness.dldir.8081</code> 
  <td>

      The download directory for the class server at port 8081.
      This is needed to support generating httpmd URLs.

<tr valign=top>
  <td><code>org.apache.river.qa.harness.shared</code>
  <td>

      if <code>true</code> (the default), all services are configured to run in
      a shared group VM. If <code>false</code>, each service runs in a private
      group.

<tr valign=top>
  <td><code>org.apache.river.qa.harness.runactivation</code>
  <td>

      if <code>true</code> (the default), the activation system identified by
      the service name <code>activationSystem</code> is started when the first
      activatable service is started, and stopped during test teardown.

<tr valign=top>
  <td><code>org.apache.river.qa.harness.runjiniserver</code>
  <td>

      if <code>true</code> (the default), the class server identified
      by the service name <code>jiniClassServer</code> is started 
      automatically in test setup, and stopped in test teardown.

<tr valign=top>
  <td><code>org.apache.river.qa.harness.runkitserver</code>
  <td>

      if <code>true</code> (the default) the class server identified
      by the service name <code>qaClassServer</code> is started 
      automatically during test setup, and stopped during test teardown.

<tr valign=top>
  <td><code>org.apache.river.qa.harness.timeout</code>
  <td>

      the number of seconds to elapse before a test timeout interrupt
      is fired. If undefined, or if the value is zero (or negative) then
      timeouts are not enabled. The default value is zero.

<tr valign=top>
  <td><code>org.apache.river.qa.harness.discardOKOutput</code>
  <td>

      if <code>true</code>, most output generated by a passing test
      is discarded. If <code>false,</code> all output is written to
      the test log. The default value is <code>false.</code>
<tr valign=top>
  <td><code>org.apache.river.qa.harness.rerunFailedTests</code>
  <td>

      if <code>true,</code> a failing test may be automatically rerun
      as determined by the <code>testMaxRetries</code> test property.
      The default value is <code>false.</code>
  
<tr valign=top>
  <td><code>org.apache.river.qa.harness.configs</code>
  <td>
  
      a comma separated list of configurations to use when running tests.
      This list may contain any combination of jrmp, jeri, http, jsse, https,
      kerberos, or none. The default value is none.
</table>

Additional properties associated with kerberos configurations and
distributed operations are defined and documented in <code>qaHarness.prop.</code>
<h2><a name="kerberos">Appendix A - Supporting Kerberos Configurations</a></h2>

The test harness includes configuration files that support testing with
kerberos as the underlying security infrastructure. However, in order to run
with kerberos some additional setup is required.

<p> 

1. In order to run the Kerberos harness configuration, you need a Kerberos KDC
(Key Distribution Center) available in your network.

<p> 

2. You also need to create principals for reggie, mahalo, outrigger, mercury,
norm, phoenix, an executing test (this is a single principal used for all
tests), fiddler, an activation group (again a single principal used for all
activation groups), a server principal, and a client principal.  Refer to your
KDC documentation for instructions on how to create principals for that
particular KDC.

<p> 

3. Once the principals needed by the harness have been created, generate an
aggregate password file containing the passwords for all the principals created
in step 2 and store this password file in a location that is accessible to the
harness.  Refer to your KDC documentation for instructions on how to create
password files for your KDC.

<p> 

4. Edit the following section in the test suite deployment properties file which
was derived from
<code>${qa.home}/src/org/apache/river/qa/resources/basicDeployment.prop</code>
supplied in the harness source distribution:

<pre>
#
# The following properties are used to specify the kerberos
# environment for tests that need to access a kdc and kerberos principals
#
org.apache.river.qa.harness.kerberos.realm=[add the realm that your KDC is serving]
org.apache.river.qa.harness.kerberos.kdc=[add the name of your KDC host]
org.apache.river.qa.harness.kerberos.clientPasswordFile=[add the location for the password file created in step 3]
org.apache.river.qa.harness.kerberos.serverPasswordFile=[add the location for the password file created in step 3]
org.apache.river.qa.harness.kerberos.aggregatePasswordFile=[add the location for the password file created in step 3]
org.apache.river.qa.harness.kerberos.clientPrincipal=[add the name of the client principal created in step 2]
org.apache.river.qa.harness.kerberos.serverPrincipal=[add the name of the client principal created in step 2]
org.apache.river.qa.harness.kerberos.reggiePrincipal=[add the name of the reggie principal created in step 2]
org.apache.river.qa.harness.kerberos.mahaloPrincipal=[add the name of the mahalo principal created in step 2]
org.apache.river.qa.harness.kerberos.outriggerPrincipal=[add the name of the outrigger principal created in step 2]
org.apache.river.qa.harness.kerberos.mercuryPrincipal=[add the name of the mercury principal created in step 2]
org.apache.river.qa.harness.kerberos.normPrincipal=[add the name of the norm principal created in step 2]
org.apache.river.qa.harness.kerberos.phoenixPrincipal=[add the name of the phoenix principal created in step 2]
org.apache.river.qa.harness.kerberos.testPrincipal=[add the name of the test principal created in step 2]
org.apache.river.qa.harness.kerberos.fiddlerPrincipal=[add the name of the fiddler principal created in step 2]
org.apache.river.qa.harness.kerberos.groupPrincipal=[add the name of the group principal created in step 2]
</pre>
</body>
</html>
